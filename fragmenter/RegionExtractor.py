import nibabel as nib
import numpy as np


class Extractor(object):

    """
    Class to extract unique indices of all regions in a
    label / annotation file.  Expects that the input file's label table
    keys are of the form "L/R_{region_name}" where L/R referes to the
    hemisphere.

    Parameters:
    - - - - -
    label_file : string
        path to input label or annotation file
    """

    def __init__(self, label_file):

        self.label_file = label_file

    def map_regions(self):

        """
        For each region in an annotation or label file, map the region
        name to the sample indices.

        Parameters:
        - - - - -
        label_file : str
            full path to annotation or label file
        """

        label_file = self.label_file

        # try loading HCP-style label file
        try:

            label_obj = nib.load(label_file)
            # get label vector
            cdata = label_obj.darrays[0].data
            # get label table mapping label values to region ID
            label_table = label_obj.labeltable.get_labels_as_dict()

            rois = list(map(str, label_table.values()))

            rois = ['_'.join(reg.split('_')[1:]) if len(reg.split('_')) > 1 else ''.join(reg.split('_')) for reg in rois]
            roi_index = list(label_table.keys())

        # otherwise try loaded freesurfer-style annotation
        except nib.filebasedimages.ImageFileError:
            cdata, ctab, roi_names = nib.freesurfer.io.read_annot(label_file)
            rois = [k.decode('utf-8') for k in roi_names]
            roi_index = [roi_names.index(np.bytes_(n)) for n in rois]
        else:
            pass
        finally:
            # exclude the first region (generally ??? or "unknown")
            reg2val = dict(zip(rois[1:], roi_index[1:]))

        parcels = {reg: np.where(
            cdata == reg2val[reg])[0] for reg in reg2val.keys()}

        return parcels

    def map_subregions(self, parcels, fragments):

        """
        For each region in parcels, generate a nested mapping structure of
        region name --> sub-region ID --> sub-region indices.

        Parameters:
        - - - - -
        parcels : dictionary
            mapping generated by get_label_table
        fragments : array
            label map generated by Fragment.fit()
        """

        subregion_parcels = {}.fromkeys(parcels.keys())

        for k in parcels.keys():

            idx = parcels[k]
            labels = fragments[idx]
            unique = np.unique(labels)

            subregion_parcels[k] = {}.fromkeys(unique)

            for u in unique:
                subregion_parcels[k][u] = idx[np.where(labels == u)[0]]

        return subregion_parcels

    def indices(self, parcelmap, regions):

        """
        Returns all indices for list of regions.

        Parameters:
        - - - - -
        parcelmap:
            dictionary of mapped indices to regions names
        regions: list
            names of regions for which to return indices
        """

        indices = []
        for r in regions:
            indices.append(parcelmap[r])
        indices = np.concatenate(indices)
        
        return indices